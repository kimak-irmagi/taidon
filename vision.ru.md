# Taidon — Vision

## 1. Введение

Taidon — это новая модель взаимодействия с базами данных, построенная вокруг идеи воспроизводимого состояния. Мы рассматриваем SQL не как поток разрозненных операций над одной «живой» базой, а как детерминированный процесс формирования состояния, в котором любая последовательность запросов однозначно определяет итоговую структуру и содержимое базы.

Этот подход позволяет устранить фундаментальное ограничение традиционных СУБД — зависимость от текущего состояния, изменяемого при каждом запросе. Он открывает путь к более предсказуемому обучению, тестированию, экспериментам и автоматизации.

## 2. Проблема, которую мы решаем

Работа с базами данных сегодня во многом напоминает работу с частью программы, состояние которой изменяется необратимо:

- Ошибка учащегося может повредить учебную базу.
- Параллельное обучение требует множества отдельных развёрток.
- Тестирование зависит от того, в каком состоянии база оказалась после предыдущих действий.
- Подготовка данных для экспериментов и проверок занимает много времени и ресурсов.
- В CI/CD каждое воспроизведение миграций и тестов — длительная и дорогостоящая операция.

Встроенные механизмы снимков состояния в существующих СУБД создавались для отказоустойчивости и транзакционной изоляции, а не для массовой работы с разветвлённой историей состояний. Они тяжеловесны, плохо масштабируются и требуют значительных аппаратных ресурсов.

## 3. Наша основная идея

Мы рассматриваем состояние базы данных как результат выполнения последовательности запросов. Система управляет выполнением этой последовательности так, чтобы состояния были:

- воспроизводимыми,
- кэшируемыми,
- общими для всех пользователей,
- доступными в нужный момент без повторного выполнения всех шагов.

Ключевые элементы подхода:

- каждая предыстория запросов имеет свой уникальный идентификатор,
- система ищет в кэше состояние, соответствующее этой предыстории,
- если оно найдено — оно восстанавливается мгновенно,
- если нет — система автоматически воспроизводит предысторию, получает новое состояние и сохраняет его,
- разветвлённые истории поддерживаются естественным образом (общая предыстория приводит к общим состояниям).

Этот принцип превращает SQL в аналог детерминированной системы сборки, только применительно к данным.

## 4. Как работает Taidon

1. Пользователь создаёт проект из SQL-скриптов, организованный в папки: например, init/, seed/, test/, bench/.
2. Taidon интерпретирует проект как граф состояний, где каждый запрос дополняет предысторию.
3. При запуске скрипта система проверяет, известно ли состояние, соответствующее предшествующим шагам.
4. Если состояние уже создано — оно разворачивается практически мгновенно.
5. Если нет — система последовательно воспроизводит всю предысторию, получает новое состояние и сохраняет его.
6. Политика хранения оптимизирует кэш по стоимости пересоздания и частоте использования.
7. Внутренняя работа — контейнеры, файловые системы с копированием-при-записи и механизм создания снимков — скрыта от пользователя.

Пользователь работает с проектом так же, как с обычной кодовой базой, не управляя вручную сервером БД.

## 5. Что получает пользователь

### Мгновенный старт

Можно начать работу сразу, без развёртывания СУБД и подготовки окружения.

### Воспроизводимость

Любой запрос можно выполнить повторно на точной копии базы — состояние вычисляется из той же последовательности запросов.

### Разветвлённые сценарии

Можно создавать параллельные варианты развития базы: разные миграции, варианты тестов, альтернативные экспериментальные запросы.

### Масштабируемость обучения

Сотни пользователей могут выполнять операции над общей логической базой, сохраняя независимость и не дублируя данные полностью.

### Точная диагностика SQL

Редактор Taidon даёт:

- корректную локализацию ошибок,
- точные сообщения PostgreSQL,
- интерактивные подсказки.

### Поддержка больших проектов

Организация SQL-скриптов и воспроизводимость состояния делают Taidon удобным и для миграций, и для CI/CD, и для сложных тестовых сценариев.

## 6. Что делает Taidon уникальным

### Мы не клонируем базу — мы вычисляем состояние

Состояние формируется повторным выполнением запросов, а не копированием файлов.

### Мы скрываем инфраструктуру

Пользователь работает с SQL, а не с контейнерами, хранилищами и файловыми системами.

### Мы используем настоящий PostgreSQL

Это обеспечивает совместимость и точность результатов.

### Мы устраняем дублирование

Разные пользователи и разные ветки могут использовать общие участки истории.

### Мы не ограничиваем профессиональное использование

Можно выполнять сложные запросы, сравнивать версии PostgreSQL, исследовать производительность.

## 7. Стратегия развития

### Этап 1 — MVP

- Базовый механизм воспроизведения цепочек запросов.
- Поддержка PostgreSQL.
- Развитие кэша состояний.
- Интерактивный редактор SQL.
- Платформенный интерфейс (CLI и базовый UI).

### Этап 2 — Расширение возможностей

- Доступ к состояниям через API.
- Дополнительные уровни тарифов.
- Поддержка альтернативных SQL-движков.
- Улучшение кэша и форматов хранения.
- Оптимизация работы с изменениями.

### Этап 3 — Универсализация

- Поддержка других классов СУБД.
- Интеграции с учебными платформами и CI/CD.
- Поддержка IDE и других инструментов (VS Code, DBeaver).

## 8. Долгосрочная цель

Создать универсальный слой воспроизводимой работы с данными, который:

- делает работу с базами данных предсказуемой,
- снижает стоимость подготовки окружений,
- масштабирует обучение,
- обеспечивает точность экспериментов,
- упрощает разработку и выпуск продуктов, сильно зависящих от БД.

Идеал: Taidon становится в мире данных тем же, чем стал Git в мире исходного кода.
