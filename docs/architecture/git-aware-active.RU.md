# Git-aware semantics: активные функции (GitHub/Git webhooks и бот)

Цель: дать “вау-эффект” за счёт автоматизации вокруг PR/веток, но **без навязывания** нового способа работы. В этом документе описаны функции, которые запускаются **по событиям GitHub/Git** или по командам в PR (slash-команды).

## Принципы дизайна

- **Opt-in по умолчанию.** Автоматизация включается либо настройкой репозитория, либо ярлыком/командой в PR.
- **Никаких секретов в PR.** DSN/пароли не публикуются в PR; получение DSN — только локально через `sqlrs`.
- **Remote режим требует доступа к репозиторию.** Для работы по `ref` нужен server-side mirror или VCS-секреты.
- **Сначала прогрев, потом сервис.** Главная ценность — подготовить окружение к моменту, когда оно нужно (ревью/QA).
- **Результат — это артефакт.** Любая автоматизация оставляет ссылку на логи и provenance.

---

## Сценарий A1. Автопрогрев кэша по PR (opened/synchronize)

### Мотивация

Самый болезненный UX — "первый запуск после пуша в PR занимает секунды/минуты". Если прогреть заранее, ревью и QA становятся мгновенными.

### Поведение (бот/хук)

Триггеры:

- PR opened
- PR synchronize (новые коммиты)
- (опционально) PR reopened

Условия запуска (варианты opt-in):

1. PR имеет label `taidon:warmup`
2. В репозитории включено правило “warmup always”
3. Комментарий-команда `/taidon warmup`

Действия:

1. Определить `head SHA` PR и (опционально) `base SHA`.
2. Сформировать список “контекстов прогрева”:
   - либо из конфигурации репо (если есть)
   - либо из явно заданных шаблонов (например, `migrations/**`)
   - либо из PR-команды (передаёт `--prepare …`)
3. Для каждого контекста выполнить пробный прогон построения state signature и прогреть цепочку снапшотов Taidon.
4. Записать provenance + логи.
5. Опубликовать результат:
   - GitHub Check Run: “DB warmup: success/fail”
   - (опционально) комментарий в PR

### Формат результата в PR

- Статус: ✅/❌
- Время прогрева
- Какие контексты прогреты (prepare paths)
- Как поднять окружение локально одной командой (пример CLI)

### Алгоритм реализации (набросок)

- GitHub App / webhook receiver
- Очередь задач (чтобы не “штормить”)
- Для каждого job:
  1. получить git-объекты (без полного checkout)
  2. вычислить хеши по prepare-контексту
  3. вызвать обычный `sqlrs run` без пользовательской команды (prepare-only)
  4. сохранить артефакты

---

## Сценарий A2. PR-команды (slash commands)

### Мотивация

Не всем нужен прогрев всегда. Команды в PR — самый "ненавязчивый" способ: пользователь сам просит действие там, где это уместно.

### UX (команды в PR)

- `/taidon warmup --prepare <path>`
- `/taidon diff --from-ref base --to-ref head --prepare <path>`
- `/taidon compare --from-ref base --from-prepare <path> --to-ref head --to-prepare <path> --run "psql -c ':'"` (ограниченно)

Правила безопасности:

- выполнять только для участников с правами (maintainers) или по allowlist
- redaction секретов в выводе
- rate limiting

### Алгоритм

- парсер команды -> задача
- контекст PR (base/head SHA)
- запуск соответствующей пассивной CLI в изолированном раннере
- публикация результата в PR как комментарий или Check Run

---

## Сценарий A3. Taidon-aware diff как GitHub Check

### Мотивация

Ревьюеру нужен быстрый сигнал: “в PR есть изменения БД?” и “какие миграции затронуты?”. Это ускоряет review и снижает риск пропустить критичные изменения.

### Поведение

Триггер:

- PR opened/synchronize

Действие:

- `sqlrs diff --from-ref <base> --to-ref <head> --prepare <path>` для каждого контекста

Результат:

- check summary:
  - DB-impact: yes/no/unknown
  - Added/Modified/Removed changesets
  - ссылка на полный отчёт (artifact)

### Алгоритм

- тот же pipeline, что A1, но лёгкая задача без поднятия СУБД

---

## Сценарий A4. Хинты для эвикции/удержания кэша из Git-событий

### Мотивация

Снапшотное хранилище ограничено. Git-события дают “семантические вехи”, которые разумно удерживать дольше.

### Политика (предложения)

- Держать дольше:
  - `main@HEAD` (последний успешный)
  - release tags `v*`
  - merge-base популярных PR (если часто тестируют)
- Держать меньше:
  - временные для закрытых PR
  - старые head commits без активности

### Поведение

Триггеры:

- push to main
- tag created
- PR closed/merged

Действия:

- приоритет/TTL метка для соответствующих snapshots/state signatures
- (опционально) закрепление “golden snapshots” после релиза

### Алгоритм

- эвиктор получает события и обновляет метаданные:
  - `priority`, `pin`, `ttl`
- периодическая “прополка” учитывает эти метки

---

## Сценарий A5. Авто-комментарии в PR (аккуратно)

### Мотивация

Комментарий полезен, если он:

- короткий
- редактируется/обновляется (не спамит)
- содержит конкретное действие (“как поднять”)

### Политика публикации

- по умолчанию: только Check Run
- комментарий: только при fail или по команде пользователя
- редактировать один “закреплённый” комментарий бота

### Шаблон комментария (пример)

- ✅ Warmup OK (N contexts)
- How to reproduce:
  - `sqlrs run --ref <head> --prepare <path> -- <cmd>`
- Links: logs, provenance

---

## Минимальный MVP активных функций

1. Slash-команда `/taidon warmup --prepare …`
2. Check Run “Taidon-aware diff” для PR (opt-in label)
3. Автопрогрев на PR synchronize при наличии label
4. TTL/priority метки для эвикции на событиях: merge, tag, PR closed




