# Git-aware semantics: пассивные функции (CLI)

Цель: добавить git-aware возможности **без вмешательства в привычный процесс работы**. Все функции в этом документе активируются **только по явной команде/флагу пользователя** и не требуют настройки репозитория "под Taidon".

## Принципы дизайна

- **Не угадываем намерения по репозиторию.** Контекст задает пользователь: `--prepare <path>` (файл/каталог миграций) и команда `sqlrs run -- <cmd>`.
- **Минимум побочных эффектов.** По умолчанию не делаем `git checkout`, не трогаем рабочее дерево и избегаем лишних временных файлов. `worktree` режим — явно включается пользователем и оставляет минимальные следы в `.git/worktrees`, которые можно удалить.
- **Сначала быстрый путь.** Сначала пытаемся найти готовое состояние в кэше Taidon по хешам задействованных файлов. Если не нашли — строим.
- **Всё воспроизводимо.** Любое выполнение умеет сохранить манифест (provenance), чтобы повторить то же состояние 1:1.
- **Remote режим требует доступа к репозиторию.** Для `--ref` на удалённом раннере нужен server-side mirror (зеркало репозитория на стороне сервиса) или VCS-секреты; иначе CLI загружает исходники в `source storage` и передает `source_id` (см. [`sql-runner-api.md`](sql-runner-api.RU.md)).

---

## Сценарий P1. Запуск по git ref без checkout: `--ref`

### Мотивация

Пользователь хочет "поднять состояние **как в коммите/ветке/теге**" не портя текущий рабочий каталог (грязное состояние, открытые IDE, параллельные задачи).

### UX / CLI

Базовый паттерн не меняется — добавляется один флаг.

```bash
sqlrs run --dbms postgres:17 \
  --workspace ./sqlrs-work \
  --ref <git-ref> \
  --prepare <path> \
  -- psql -c "select 1"
```

Где `<git-ref>`: `HEAD`, `origin/main`, `abc1234`, `v1.2.3`, `refs/pull/123/head` (если доступно локально).

Важно для удалённого раннера: `--ref` работает только если у сервиса есть доступ к репозиторию
(server-side mirror или настроенные VCS-секреты для клона/чтения). Иначе CLI должен заранее
загрузить исходники в `source storage` и передать `source_id` (см. [`sql-runner-api.md`](sql-runner-api.RU.md)).

Опции поведения:

- `--ref-mode blob|worktree` (по умолчанию `blob`)
  - `blob`: читать нужные файлы прямо из git-объектов (без извлечения всего репо)
  - `worktree`: создать временный `git worktree` и удалить после выполнения
- `--ref-keep-worktree` (для отладки: не удалять временный worktree)

### Алгоритм реализации (набросок)

1. Определить корень репозитория (если нет — ошибка `not a git repo`).
2. Разрешить `<git-ref>` в `commit/tree`.
3. Получить список файлов под `--prepare` и blob-хеши:
   - blob-mode: `git ls-tree -r <ref> -- <path>` (без checkout)
   - worktree-mode: `git worktree add --detach <tmpdir> <ref>`
4. Посчитать хеши входных файлов по `blob OID` (и, опционально, ключевых зависимостей: конфиги, include-файлы).
5. Сформировать цепочку изменений и запросить кэш Taidon.
6. Если попадание в кэш — вернуть/использовать готовое состояние.
7. Иначе: прочитать содержимое нужных файлов (blob или worktree), выполнить `prepare` (миграции/скрипты) в Taidon и создать снапшоты.
8. Продолжить `sqlrs run -- <cmd>` в полученном окружении.
9. Сгенерировать provenance (см. P4), если включено.

---

## Сценарий P2. Zero-copy cache hit (ускорение без извлечения файлов)

### Мотивация

В больших репозиториях извлечение/checkout дорого, хотя Taidon может уже иметь нужное состояние по хешам миграций.

### UX / CLI

Включается автоматически при `--ref-mode blob` (или отдельным флагом):

```bash
sqlrs run --ref <ref> --ref-mode blob --prepare migrations/ -- <cmd>
```

Опционально:

- `--zero-copy=auto|off` отключить оптимизацию или оставить авто-режим

### Алгоритм реализации

1. В blob-mode получить список файлов и их blob-хеши через `git ls-tree`.
2. Посчитать ключи кэша по хешам.
3. Проверить кэш Taidon **до** извлечения файлов.
4. Если попадание в кэш — не извлекать файлы на диск, сразу выдавать окружение.

Примечание: если нужные blob-объекты отсутствуют локально (`partial clone`/LFS), потребуется `git fetch` или переход в `worktree` режим.

---

## Сценарий P3. Taidon-aware diff по явному контексту: `diff`

### Мотивация

Обычный `git diff` показывает текст, но пользователю нужен ответ “что изменилось **в БД**, учитывая **ровно те файлы**, которые мы запускаем”.

### UX / CLI

### 3.1 Diff по ref-ам и prepare-контексту

```bash
sqlrs diff --from-ref <refA> --to-ref <refB> --prepare <path>
```

Вывод (предлагаемый):

- список changeset-ов: Added/Modified/Removed
- порядок исполнения (если применимо)
- краткая сводка (количество миграций/строк)
- (опционально) "DB impact: yes/no/unknown"

Опции:

- `--format text|json`
- `--include-content` (показывать фрагменты)
- `--limit N`

### 3.2 Diff двух локальных наборов (без Git)

```bash
sqlrs diff --from-path <pathA> --to-path <pathB>
```

### Алгоритм реализации

1. Загрузить файлы контекста из `from-ref`/`to-ref` или `from-path`/`to-path` (blob/worktree).
2. Нормализовать список входов (каталог, то есть упорядоченный набор файлов).
3. Посчитать хеши и сравнить:
   - Added/Removed по пути
   - Modified по хешу
4. (Опционально) Построить семантическую подсказку:
   - если только комментарии/whitespace (эвристика) — "низкое влияние"
5. Сформировать отчёт.

---

## Сценарий P4. Provenance (execution manifest)

### Мотивация

В реальных командах быстро возникает вопрос “что именно ты запускал?”. Нужен артефакт, который можно приложить к багрепорту или повторить через месяц.

### UX / CLI

Автовключение по флагу или настройке:

```bash
sqlrs run --provenance write --provenance-path ./artifacts/provenance.json -- <cmd>
```

Режимы:

- `write` — записать файл
- `print` — вывести кратко в stdout
- `both`

Содержимое (минимум):

- timestamp (время запуска)
- git ref + commit (если задан `--ref`)
- `dirty/clean` (грязное/чистое состояние рабочего дерева)
- список входных файлов `--prepare` + хеши
- параметры окружения (`dbms.image`, важные флаги)
- цепочка снапшотов Taidon, использованные base/derived
- команда `sqlrs run -- <cmd>` + argv

### Алгоритм реализации

1. На старте собрать “контекст запуска”.
2. Во время `prepare` фиксировать цепочку снапшотов и ключевые решения (попадания/промахи кэша).
3. На выходе сериализовать JSON (и, опционально, текстовую сводку).

---

## Сценарий P5. Compare: один запрос на двух состояниях

### Мотивация

QA/разработчику нужно быстро сравнить результат/ошибку на двух версиях схемы (например, base и PR).

### UX / CLI

```bash
sqlrs compare \
  --from-ref <refA> --from-prepare <path> \
  --to-ref <refB> --to-prepare <path> \
  -- psql -c "select * from flights limit 10"
```

Вывод:

- exit codes
- stderr/stdout (с лимитами)
- (опционально) diff результатов в табличном формате

Опции:

- `--diff text|json|table`
- `--timeout-ms 5000`
- `--max-rows 1000`

### Алгоритм реализации

1. Для `from-ref` и `to-ref` поднять окружение (с кэшем).
2. Выполнить одну и ту же команду.
3. Собрать результаты и сформировать сравнение.

---

## Сценарий P6. “Explain cache”: почему быстро/медленно

### Мотивация

Пользователь хочет понять, почему в этот раз было "долго": не было снапшота? изменились хеши? другой движок?

### UX / CLI

```bash
sqlrs cache explain --ref <ref> --prepare <path>
```

Вывод:

- вычисленные хеши changeset-ов
- ближайшая опорная точка (если есть)
- причина промаха (нет снапшота / несовпадение движка/версии / отсутствует сегмент цепочки)

### Алгоритм реализации

1. Построить тот же ключ(и), что и для `migrate/run`.
2. Запросить индекс кэша.
3. Отрендерить объяснение.

---

## Минимальный MVP пассивных функций

1. `--ref` (blob-mode) + zero-copy cache hit
2. `sqlrs diff --from-ref/--to-ref --prepare <path>`
3. provenance (write)
4. `cache explain` (простая версия)






