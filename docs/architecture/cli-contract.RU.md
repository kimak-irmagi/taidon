# Контракт CLI sqlrs (черновик)

Этот документ определяет **предварительный пользовательский контракт CLI** для `sqlrs`.
Он намеренно неполный и эволюционный, по духу близок к ранним версиям CLI `git` или `docker`.

Цели:

- закрепить стабильную _ментальную модель_ для пользователя,
- определить пространства команд и ответственности,
- направлять внутренние решения по API и UX.

---

## 0. Принципы дизайна

1. **Каноническое имя CLI**: `sqlrs`
2. **Интерфейс на подкомандах** (стиль git/docker)
3. **Явное состояние вместо неявной магии**
4. **Композиция команд** (plan -> apply -> run -> inspect)
5. **По умолчанию машинно-дружественный вывод** (JSON где уместно)
6. **Человеко-читаемые сводки** при интерактивном запуске

---

## 1. Высокоуровневая ментальная модель

С точки зрения пользователя `sqlrs` управляет:

- **states**: неизменяемые состояния БД, получаемые детерминированным процессом prepare
- **instances**: изменяемые копии states; все модификации БД происходят здесь
- **plans**: упорядоченные наборы изменений (например, Liquibase changesets)
- **runs**: исполнение планов, скриптов или команд

```text
state  --(materialize)-->  instance  --(run/apply)-->  new state
```

---

## Конвенция формы команд

Во всех командах sqlrs используется следующая форма:

```text
sqlrs <verb>[:<kind>] [subject] [options] [-- <command>...]
```

- `<verb>` - основная команда (`prepare`, `run`, `ls`, ...).
- `:<kind>` - опциональный селектор исполнителя/адаптера (например, `prepare:psql`, `run:pgbench`).
- `subject` - опциональный аргумент, зависит от команды (например, id инстанса, имя и т.п.).
- `-- <command>...` используется только для команд, выполняющих внешнюю команду (в основном `run`).

`sqlrs ls` не использует `:<kind>` и не принимает `-- <command>...`.

## Правила префиксов id

Там, где CLI ожидает **id состояния или инстанса**, пользователь может передать
hex-префикс (минимум 8 символов). CLI разрешает префикс без учета регистра и
сообщает об ошибке при неоднозначности.

Job id считаются **непрозрачными и должны задаваться целиком**; префиксы для job не поддерживаются.

## 2. Группы команд (неймспейсы)

```text
sqlrs
  init
  status
  ls
  rm
  prepare
  plan
  run
```

Не все группы требуются в MVP.

---

## 3. Основные команды (MVP)

### 3.1 `sqlrs init`

Актуальная семантика команды описана в user guide:

- [`docs/user-guides/sqlrs-init.md`](../user-guides/sqlrs-init.md)

---

### 3.2 `sqlrs status`

Проверяет здоровье локального или удаленного engine и выводит детали статуса.

```bash
sqlrs status [options]
```

---

### 3.3 `sqlrs ls`

Актуальная семантика команды описана в user guide:

- [`docs/user-guides/sqlrs-ls.md`](../user-guides/sqlrs-ls.md)

---

### 3.4 `sqlrs rm`

Актуальная семантика команды описана в user guide:

- [`docs/user-guides/sqlrs-rm.md`](../user-guides/sqlrs-rm.md)

---

### 3.5 `sqlrs prepare`

Актуальная семантика команды описана в user guide:

- [`docs/user-guides/sqlrs-prepare.md`](../user-guides/sqlrs-prepare.md)

TODO (будущее):

- Добавить `prepare:liquibase` (alias: `prepare:lb`).
- Добавить именованные экземпляры и флаги привязки (`--name`, `--reuse`, `--fresh`, `--rebind`).
- Добавить async-режим (`--watch/--no-watch`) с выводом `prepare_id` и URL статуса.

---

### 3.6 `sqlrs plan`

Актуальная семантика команды описана в user guide:

- [`docs/user-guides/sqlrs-plan.md`](../user-guides/sqlrs-plan.md)

---

### 3.7 `sqlrs run`

Актуальная семантика команды описана в user guide:

- [`docs/user-guides/sqlrs-run.md`](../user-guides/sqlrs-run.md)

---

## 4. Вывод и скриптинг

- Вывод по умолчанию: человеко-читаемый
- `--json`: машинно-читаемый
- Стабильные схемы для JSON-вывода

Подходит для CI/CD.

---

## 5. Источники входа (локальные пути, URL, удаленные загрузки)

Везде, где CLI ожидает файл или директорию, он принимает:

- локальный путь (файл или директория)
- публичный URL (HTTP/HTTPS)
- серверный `source_id` (предыдущая загрузка)

Поведение зависит от цели:

- локальный engine + локальный путь: передать путь напрямую
- удаленный engine + публичный URL: передать URL напрямую
- удаленный engine + локальный путь: загрузить в source storage (чанками) и передать `source_id`

Это держит `POST /runs` компактным и дает возобновляемые загрузки для больших проектов.

---

## 6. Совместимость и расширяемость

- Liquibase рассматривается как внешний планировщик/исполнитель
- CLI не раскрывает Liquibase internals напрямую
- Будущие бэкенды (Flyway, raw SQL, кастомные планировщики) вписываются в тот же контракт

---

## 7. Не-цели (для этого CLI контракта)

- Полный паритет с опциями Liquibase CLI
- Интерактивный TUI
- GUI bindings

---

## 8. Открытые вопросы

- Разрешать ли несколько prepare/run шагов на invocation? (см. user guides)
- Должен ли `plan` быть неявным в `migrate` или всегда явным?
- Сколько истории состояний показывать по умолчанию?
- Нужны ли флаги подтверждения для destructive операций?

---

## 9. Философия

`sqrls` (sic) — это не база данных.

Это **движок управления состояниями и выполнения** для баз данных.

CLI должен делать переходы состояний явными, инспектируемыми и воспроизводимыми.
