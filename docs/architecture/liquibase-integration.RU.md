# Дизайн интеграции Taidon и Liquibase

Этот документ описывает, как Taidon взаимодействует с Liquibase, не переимплементируя его внутренности (парсинг changelog, фильтры, порядок). Фокус на:

- получении "плана" (pending changesets)
- получении стабильных хешей шагов (checksums), когда это возможно
- максимизации cache hits через rewind (перемотку по кэшированным состояниям)
- пошаговом выполнении changesets и безопасном snapshotting

---

## Содержание

- [1. Область](#1-область)
- [2. Режимы интеграции](#2-режимы-интеграции)
- [3. Наблюдаемость через структурированные логи](#3-наблюдаемость-через-структурированные-логи)
- [4. Планирование](#4-планирование)
- [5. Хеш-горизонт и волатильность](#5-хеш-горизонт-и-волатильность)
- [6. Алгоритм перемотки кэша](#6-алгоритм-перемотки-кэша)
- [7. Выполнение шагов и snapshotting](#7-выполнение-шагов-и-snapshotting)
- [8. Обработка сбоев и режимы совместимости](#8-обработка-сбоев-и-режимы-совместимости)
- [9. Ключи кэша и параметры](#9-ключи-кэша-и-параметры)
- [10. Операционные соображения](#10-операционные-соображения)
- [11. Открытые вопросы](#11-открытые-вопросы)

---

## 1. Область

### Входит в область

- Оркестрация Liquibase CLI со стороны Taidon ("master" / wrapper)
- Пошаговое применение (`update-count 1`) и snapshotting после каждого changeset
- Предиктивный cache lookup по checksum changeset, когда это возможно
- Обработка volatile/unknown шагов через материализацию состояния и продолжение

### Вне области (MVP)

- Прямое чтение БД Taidon-ом (например, `DATABASECHANGELOG`)
- Реализация парсинга changelog Liquibase (XML/YAML/JSON/SQL)
- Snapshotting в середине транзакции

---

## 2. Режимы интеграции

### 2.1 Liquibase Master (рекомендуется)

Пользователь запускает Taidon CLI. Taidon оркестрирует Liquibase.

- Плюсы: лучший cache hit rate, детерминированная оркестрация, проще пошаговое выполнение
- Минусы: пользователям нужно принять `taidon migrate` (или аналог)

### 2.2 Liquibase Wrapper (совместимость)

Пользователь запускает `taidon-liquibase` wrapper, который проксирует большинство флагов в Liquibase.

- Плюсы: минимальные изменения workflow для существующих команд
- Минусы: для полного эффекта кэширования все равно нужен wrapper

### 2.3 Drop-in DB Proxy (позже)

DB proxy/driver наблюдает коммиты и делает снапшоты. Предиктивное кэширование ограничено, если клиент не предоставляет явные границы блоков.

### 2.4 Среды выполнения

Выполнение Liquibase абстрагировано так, чтобы движок мог запускать его в разных окружениях.

**Текущее (локально Windows + engine в WSL):**

- Движок запускает Liquibase как **Windows‑исполняемый файл** через WSL interop.
- Пути переводятся из WSL (`/mnt/c/...`) в Windows (`C:\...`) до запуска.
- `liquibase.exec` в конфиге (если задан) переопределяет PATH.

**Будущее (контейнер):**

- Движок запускает Liquibase в **отдельном контейнере**.
- Пути переводятся из WSL в пути монтирования контейнера.
- Интерфейс выполнения остаётся тем же; меняются только runner и path mapper.

Маппинг путей реализуется через **интерфейс PathMapper** с реализациями
WSL->Windows и WSL->Container.

---

## 3. Наблюдаемость через структурированные логи

Taidon рассматривает Liquibase как источник истины и наблюдает выполнение через структурированные JSON-логи.

### 3.1 Обязательные свойства логов

- `logFormat`: `JSON` или `JSON_PRETTY`
- `logLevel`: минимум `INFO` (настраивается)
- стабильные поля корреляции:
  - operation id / run id
  - идентификаторы changeset (если есть)
  - checksum (если есть)

### 3.2 Минимальные события, которые нужны Taidon

- `plan.pending`: список pending changeset (или возможность его восстановить)
- `step.start`: changeset вот-вот будет выполнен
- `step.applied`: changeset успешно применен
- `step.failed`: changeset завершился с ошибкой

Taidon не должен зависеть от человеко-читаемых сообщений логов.

---

## 4. Планирование

Taidon получает план pending changeset, вызывая команды Liquibase с теми же фильтрами и параметрами, которые будут использованы для выполнения.

### 4.3 Блокировка контента (атомарность)

Чтобы избежать plan drift, Taidon захватывает **read-lock** на все входы Liquibase
на время каждого task:

- планирование (`updateSQL`): блокировать changelog + referenced files на время построения плана
- выполнение (`update-count 1`): блокировать тот же набор на время применения шага

Если lock нельзя получить (файл изменяется), task завершается ошибкой.

### 4.1 Входы, влияющие на план

- путь к changelog
- фильтры contexts / labels
- DBMS filters
- changelog параметры (подстановка property)
- версия Liquibase

### 4.2 Выход планирования

План — это упорядоченный список шагов:

- `step_index` (0..n-1)
- `changeset_ref` (непрозрачная ссылка для логов/диагностики)
- `checksum` (опционально; может быть неизвестен заранее)
- `is_volatile` (опционально; может быть неизвестен заранее)

---

## 5. Хеш-горизонт и волатильность

### 5.1 Цель

Вычислить хеши для максимально возможного числа ближайших шагов _без их выполнения_, затем перемотаться по кэшу до последнего доступного состояния.

### 5.2 Определение горизонта

**Хеш-горизонт** — это самый длинный префикс pending-плана, для которого Taidon может получить стабильные `block_hash`.

Горизонт заканчивается, когда:

- checksum недоступен без выполнения предыдущих шагов
- Liquibase помечает шаг как volatile (SQL не детерминируется статически)
- данные плана неполны или противоречивы

### 5.3 Практическая стратегия горизонта (MVP)

- Пытаться получить checksum на этапе планирования.
- Если checksum отсутствует для шага `k`, считать `k` концом горизонта.
- Если Liquibase позже раскрыл checksum после материализации, расширить горизонт и продолжить перемотку.

---

## 6. Алгоритм перемотки кэша

### 6.1 Намерение

Найти самое продвинутое кэшированное состояние, достижимое от `original_base_id`, применяя известные хеши шагов (без выполнения).

### 6.2 Высокоуровневый поток

```mermaid
flowchart TD
  A[Start: original_base_id] --> B[Plan pending changesets via Liquibase]
  B --> C[Compute hashes until horizon]
  C --> D[Rewind: walk cache forward by hashes]
  D -->|miss or horizon end| E[Materialize instance from last cached state]
  E --> F[Execute steps (update-count 1) + snapshot]
  F --> G[Try to extend horizon and rewind again]
  G -->|no pending| H[Done: final_state_id]
```

### 6.3 Детали перемотки

Дано:

- `base_id` (изначально `original_base_id`)
- `hashes[]` для шагов `i..j` (в пределах горизонта)

Цикл перемотки:

1. Вычислить `key = H(engine, base_id, hashes[next], exec_params)`.
2. Если `key` найден в кэше:
   - установить `base_id = cached_state_id`
   - перейти к следующему хешу
3. Иначе:
   - остановиться. Следующий шаг нужно выполнить.

Во время перемотки экземпляр не создается.

---

## 7. Выполнение шагов и snapshotting

### 7.1 Правило материализации

Когда перемотка останавливается (cache miss или конец горизонта), Taidon материализует экземпляр из последнего известного `base_id`.

### 7.2 Пошаговое выполнение

Taidon запускает Liquibase в пошаговом режиме:

- `update-count 1` повторяется до тех пор, пока:
  - не останется pending changeset, или
  - выполнение не завершится ошибкой

### 7.3 Триггер snapshot

После каждого успешного `update-count 1`:

- создать новый State snapshot
- сохранить `key(base_id, block_hash, exec_params) -> new_state_id`
- обновить `current_base_id = new_state_id`

### 7.4 Переключение экземпляра при cache hit

Если для следующих шагов обнаружен cache hit:

- прекратить использование текущего экземпляра
- создать новый экземпляр из кэшированного State
- продолжить выполнение Liquibase

Это сохраняет непрерывность пользовательского опыта, при этом физически меняя базу.

### 7.5 Проверка "дрейфа плана"

После материализации Taidon должен убедиться, что Liquibase применяет ожидаемый следующий шаг:

- сравнить next-step reference, наблюдаемую в логах, с предсказанным шагом
- при несовпадении завершить с ошибкой "plan drift"

---

## 8. Обработка сбоев и режимы совместимости

### 8.1 Категории отказов

- **Сбой транзакционного changeset** (`runInTransaction=true`): должен откатиться, оставив БД неизменной на этом шаге.
- **Сбой нетранзакционного changeset** (`runInTransaction=false`): может частично примениться.

### 8.2 Диагностический snapshot (опционально)

При ошибке Taidon может сохранить snapshot отказавшего экземпляра для расследования.

- `status=failed`
- исключается из автоматического cache lookup
- может быть закреплен/тегирован пользователем явно

### 8.3 Режимы совместимости для `current_base_id`

- **Conservative (last-success)**:
  - установить `current_base_id` на последний успешный snapshot
  - считать, что неудачный нетранзакционный шаг не был закреплен для будущих запусков
- **Investigative (failed-base)**:
  - установить `current_base_id` на диагностический failed snapshot
  - позволить пользователям воспроизводить и разбираться с ошибкой

---

## 9. Ключи кэша и параметры

### 9.1 Канонический ключ

```c
key = H(
  engine_id,
  engine_version,
  base_state_id,
  block_hash,
  execution_params
)
```

### 9.2 Параметры выполнения

`execution_params` должны включать любые входы, меняющие результат:

- contexts / labels
- dbms filter
- changelog parameters (property substitution)
- версия Liquibase (пока не доказано, что можно опускать)
- environment flags, влияющие на выполнение

### 9.3 Источник block_hash

`block_hash` является **контентным**:

- предпочтительно: checksum Liquibase (когда доступен без выполнения)
- fallback: хеш SQL, который Liquibase выдаёт для этого changeset (`updateSQL`)

Идентичность changeset (author/id/path) фиксируется для диагностики/UX и
обнаружения plan drift, но **не** участвует в cache key.

---

## 10. Операционные соображения

### 10.1 Объем логов

JSON-логи могут быть очень большими для крупных SQL-пейлоадов.

- предпочтительно писать логи в файл и стримить/обрабатывать их инкрементально
- поддерживать настройку уровня логирования
- хранить только необходимые ключи/поля для долгого срока

### 10.2 Конкурентность

- Каждый экземпляр изолирован; запуск Liquibase не должен шарить одну DB-инстанцию.
- Индекс кэша должен быть concurrency-safe (атомарная вставка key->state).

### 10.3 Безопасность

- секреты в параметрах должны маскироваться/редактироваться при хранении логов
- не сохранять исходный SQL, если это явно не включено

---

## 11. Открытые вопросы

- Как надежнее всего получить checksum на шаг до выполнения, используя только Liquibase invocations?
- Как Taidon должен выявлять volatile шаги из структурированных логов между версиями Liquibase?
- Нужен ли лимит глубины перемотки или ранняя остановка по эвристикам стоимости пересчета?
