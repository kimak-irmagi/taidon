# Эвикшн кеша снапшотов в версионированном хранилище БД

## 1. Контекст и постановка задачи

В Taidon состояние БД рассматривается как **версионируемый артефакт**, подобный коммитам в системе контроля версий. Каждая версия БД реализована как снапшот поверх Copy-on-Write (CoW) файловой системы (например, ZFS).

Снапшоты формируют **ориентированный ациклический граф (DAG)**:

- узлы представляют снапшоты базы,
- ребра отражают отношения parent -> child, возникающие при snapshot/clone.

Типичные CI/CD нагрузки генерируют снапшоты с высокой частотой. Эти снапшоты:

- создаются и удаляются в больших количествах,
- сильно отличаются по частоте повторного использования и ценности,
- конкурируют за ограниченную емкость хранилища.

Этот документ описывает практический подход к **автоматическому управлению размером кэша** для таких снапшотов.

---

## 2. Ограничения и требования

### 2.1 Архитектурные ограничения

1. **CoW файловая система**

   - Хранение опирается на блок-шэринг CoW файловой системы.
   - Эффективность достигается за счет разделения неизмененных блоков между снапшотами.

2. **Гарантии корректности**

   - Удаление снапшота не должно ломать доступ к оставшимся.
   - К эвикшну допускаются только **листовые снапшоты** в DAG.

3. **Механизм pinning**

   - Снапшоты могут быть исключены из эвикшна через pin:
     - ручной pin (пользователь или политика),
     - активное использование (смонтированная или выполняющаяся среда),
     - временная защита (grace period / TTL).

4. **Персистентные метаданные**
   - Логические метаданные снапшотов могут сохраняться даже после физического удаления,
     чтобы поддерживать учет, статистику доступа и восстановление.

---

### 2.2 Операционные требования

1. **Стабильность**

   - Система должна избегать thrashing (быстрое создание с немедленным удалением).

2. **Предсказуемость**

   - Освобождаемое место должно коррелировать с решениями эвикшна понятным образом.

3. **Локальное принятие решений**

   - Решения должны опираться на локальные метрики,
     без глобальной пересборки всего графа снапшотов.

4. **Масштабируемость**
   - Подход должен оставаться практичным при тысячах и десятках тысяч снапшотов.

---

## 3. Модель управления кэшем

Используется модель **high watermark / low watermark (HWM/LWM)**:

- При превышении **high watermark** запускается эвикшн.
- Эвикшн продолжается, пока использование не опустится ниже **low watermark**.
- Эвикшн состоит из повторяющихся операций удаления снапшотов.

---

## 4. Эвикшн как примитивная операция

### 4.1 Определение

**Операция эвикшна** включает:

1. выбор кандидата на эвикшн,
2. физическое удаление из CoW файловой системы,
3. фиксацию результата (освобожденное место, время, побочные эффекты).

---

### 4.2 Набор кандидатов

Снапшот может рассматриваться как кандидат на эвикшн, если выполняются все условия:

- это **лист** в DAG снапшотов,
- он **не закреплен** (не pinned),
- он **не используется активно**,
- он старше минимального возраста, заданного политикой.

---

## 5. Целевые метрики

### 5.1 Высокоуровневая цель

Политика эвикшна стремится **максимально освобождать место при минимизации ожидаемой будущей стоимости**.

Интуитивно:

> Удалять снапшоты, которые освобождают много места и вряд ли понадобятся,
> или которые дешево восстановить, если понадобятся.

---

### 5.2 Измеримые прокси-метрики

#### 1. Оценка освобождаемого места

`freed_space(snapshot)`

Оценивается через статистику CoW файловой системы:

- для ZFS — значение `used` у листового снапшота;
- аналогичные метрики для других CoW систем.

Для листовых снапшотов это хорошая аппроксимация их реального вклада в размер.

---

#### 2. Вероятность доступа

`access_frequency(snapshot)`

Производится из:

- прямых обращений к снапшоту,
- опционально, обращений к его потомкам,
- с учетом временного затухания.

Эта метрика оценивает вероятность, что снапшот понадобится снова.

---

#### 3. Стоимость восстановления

Оценка стоимости, если снапшот придется пересоздавать после эвикшна.

Изначально моделируется через:

- историческую стоимость создания,
- частоту доступа,
- грубые эвристики сложности пересборки.

Для листовых снапшотов стоимость восстановления считается **локальной**, независимой от других снапшотов.

---

### 5.3 Композитный скоринг

Кандидаты ранжируются по композитной эвристике, которая балансирует:

- ожидаемую пользу по месту,
- вероятность повторного использования,
- ожидаемую стоимость восстановления.

Точная функция скоринга требует настройки и экспериментов.

---

## 6. Варианты алгоритма эвикшна

### 6.1 Greedy эвикшн

1. Собрать все допустимые листовые снапшоты.
2. Посчитать score для каждого кандидата.
3. Удалять снапшоты с лучшим score, пока не достигнут LWM.

Плюсы:

- просто и прозрачно.

Минусы:

- чувствительно к шуму метрик.

---

### 6.2 Batch-based эвикшн

- Эвикшн выполняется пакетами.
- Score пересчитывается только между пакетами.

Плюсы:

- ниже overhead,
- более стабильное поведение.

---

### 6.3 Age-tiered эвикшн

- Снапшоты группируются по возрасту.
- Эвикшн начинается со старшего тира.
- Скоринг применяется внутри каждого тира.

Плюсы:

- защищает свежие снапшоты от преждевременного удаления.

---

### 6.4 Retention по классам

- Снапшотам назначаются классы retention:
  - ephemeral (CI-прогоны),
  - semi-persistent (PR-related),
  - persistent (релизы).
- Эвикшн ограничивается внутри классов.

Плюсы:

- проще объяснить поведение продукта,
- ниже риск удалить критичные снапшоты.

---

## 7. Известные ограничения

- Подход эвристический и не глобально оптимален.
- Владение хранилищем лишь аппроксимируется, а не считается точно.
- Удаляются только листовые снапшоты.
- Избыточный pinning может помешать достаточному освобождению места.

Эти ограничения считаются приемлемыми для первой production-реализации.
