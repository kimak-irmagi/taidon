name: ci

on:
  pull_request:
  push:
    branches:
      - main

jobs:
  docs-sync:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          fetch-depth: 0

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Enable pnpm
        run: corepack enable

      - name: Use pnpm
        run: corepack prepare pnpm@10.26.2 --activate

      - name: Lint OpenAPI
        run: pnpm run lint:openapi

      - name: Generate OpenAPI docs (markdown)
        run: pnpm run docs:openapi:md

      - name: Generate schema docs (markdown)
        run: pnpm run docs:schemas

      - name: Commit regenerated docs
        if: github.event.pull_request.head.repo.full_name == github.repository
        run: |
          if git diff --quiet; then
            echo "Docs are up to date."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add docs
          git commit -m "chore(docs): regenerate api docs"
          git push

      - name: Fail if docs are out of date (forks)
        if: github.event.pull_request.head.repo.full_name != github.repository
        run: git diff --exit-code

  coverage:
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        runner: [ubuntu-latest, windows-latest, macos-latest]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go (engine)
        uses: actions/setup-go@v5
        with:
          go-version-file: backend/local-engine-go/go.mod

      - name: Run engine coverage
        working-directory: backend/local-engine-go
        shell: bash
        run: go test ./... -covermode=count -coverprofile=../../coverage-engine-${{ matrix.runner }}.out

      - name: Set up Go (cli)
        uses: actions/setup-go@v5
        with:
          go-version-file: frontend/cli-go/go.mod

      - name: Run CLI coverage
        working-directory: frontend/cli-go
        shell: bash
        run: go test ./... -covermode=count -coverprofile=../../coverage-cli-${{ matrix.runner }}.out

      - name: Upload coverage artifacts
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.runner }}
          path: |
            coverage-engine-${{ matrix.runner }}.out
            coverage-cli-${{ matrix.runner }}.out

  coverage-merge:
    runs-on: ubuntu-latest
    needs: coverage
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: backend/local-engine-go/go.mod

      - name: Download coverage artifacts
        uses: actions/download-artifact@v4
        with:
          path: coverage-artifacts

      - name: Merge coverage
        id: coverage
        shell: bash
        run: |
          set -euo pipefail

          mapfile -t engine_files < <(find coverage-artifacts -name 'coverage-engine-*.out' -print | sort)
          mapfile -t cli_files < <(find coverage-artifacts -name 'coverage-cli-*.out' -print | sort)
          if [[ ${#engine_files[@]} -eq 0 || ${#cli_files[@]} -eq 0 ]]; then
            echo "missing coverage artifacts"
            exit 1
          fi

          merge_profiles() {
            local output=$1
            shift
            awk 'BEGIN{FS=" "} $1!="mode:"{key=$1" "$2; if(!(key in max) || $3>max[key]) max[key]=$3} END{for(k in max){print k" "max[k]}}' "$@" \
              | sort > "${output}.body"
            echo "mode: set" > "$output"
            cat "${output}.body" >> "$output"
            rm -f "${output}.body"
          }

          merge_profiles coverage-engine.raw "${engine_files[@]}"
          merge_profiles coverage-cli.raw "${cli_files[@]}"
          merge_profiles coverage.raw coverage-engine.raw coverage-cli.raw

          total=$(go tool cover -func=coverage.raw | awk '/^total:/ {print $3}')
          engine=$(go tool cover -func=coverage-engine.raw | awk '/^total:/ {print $3}')
          cli=$(go tool cover -func=coverage-cli.raw | awk '/^total:/ {print $3}')
          echo "total=$total" >> "$GITHUB_OUTPUT"
          echo "engine=$engine" >> "$GITHUB_OUTPUT"
          echo "cli=$cli" >> "$GITHUB_OUTPUT"

          python - <<'PY'
          import os, re

          workspace = os.environ.get("GITHUB_WORKSPACE", "")
          workspace = os.path.normpath(workspace) if workspace else ""
          pattern = re.compile(r"^(.+):(\d+\.\d+,\d+\.\d+\s+\d+\s+\d+)$")

          def normalize_path(path: str) -> str:
              if workspace:
                  norm = os.path.normpath(path)
                  if os.path.isabs(norm) and norm.startswith(workspace):
                      path = os.path.relpath(norm, workspace)
              if path.startswith("sqlrs/engine/"):
                  path = path.replace("sqlrs/engine/", "backend/local-engine-go/", 1)
              elif path.startswith("sqlrs/cli/"):
                  path = path.replace("sqlrs/cli/", "frontend/cli-go/", 1)
              return path.replace("\\", "/")

          def resolve_existing(path: str) -> str:
              candidates = [path]
              if not os.path.isabs(path):
                  candidates.append(os.path.join("frontend", "cli-go", path))
                  candidates.append(os.path.join("backend", "local-engine-go", path))
                  candidates.append(os.path.join("frontend", "cli-go", "internal", path))
                  candidates.append(os.path.join("backend", "local-engine-go", "internal", path))
              for candidate in candidates:
                  if not workspace:
                      return candidate.replace("\\", "/")
                  full = os.path.normpath(os.path.join(workspace, candidate))
                  if os.path.isfile(full):
                      return os.path.relpath(full, workspace).replace("\\", "/")
              if workspace and os.path.isabs(path):
                  return os.path.relpath(path, workspace).replace("\\", "/")
              if workspace:
                  return os.path.normpath(path).replace("\\", "/")
              return path.replace("\\", "/")

          def rewrite(path: str, out_path: str) -> None:
              out_lines = []
              unresolved = []
              with open(path, "r", encoding="utf-8") as fh:
                  for line in fh:
                      line = line.rstrip("\n")
                      if line.startswith("mode:"):
                          out_lines.append(line)
                          continue
                      match = pattern.match(line)
                      if not match:
                          out_lines.append(line)
                          continue
                      raw_path = match.group(1)
                      file_path = normalize_path(raw_path)
                      resolved = resolve_existing(file_path)
                      if workspace and not os.path.isfile(resolved):
                          unresolved.append(raw_path)
                      out_lines.append(f"{resolved}:{match.group(2)}")
              with open(out_path, "w", encoding="utf-8") as fh:
                  fh.write("\n".join(out_lines) + "\n")
              if unresolved:
                  print("unresolved coverage paths (sample):")
                  for path in unresolved[:10]:
                      print(" -", path)

          rewrite("coverage.raw", "coverage.out")
          PY

      - name: Debug coverage path formats
        shell: bash
        run: |
          set -euo pipefail
          echo "coverage.out first lines:"
          head -n 5 coverage.out
          python - <<'PY'
          import re
          drive = re.compile(r"^[A-Za-z]:\\\\")
          abs_posix = re.compile(r"^/")
          total = 0
          drive_hits = []
          abs_hits = []
          with open("coverage.out", "r", encoding="utf-8") as fh:
              for line in fh:
                  if line.startswith("mode:"):
                      continue
                  total += 1
                  path = line.split(":", 1)[0]
                  if drive.match(path):
                      if len(drive_hits) < 5:
                          drive_hits.append(path)
                  if abs_posix.match(path):
                      if len(abs_hits) < 5:
                          abs_hits.append(path)
          print(f"total lines: {total}")
          print(f"windows-drive paths: {len(drive_hits)} sample={drive_hits}")
          print(f"posix-abs paths: {len(abs_hits)} sample={abs_hits}")
          PY

      - name: Show coverage paths (debug)
        shell: bash
        run: |
          set -euo pipefail
          echo "coverage.out sample:"
          head -n 5 coverage.out
          echo "coverage.raw sample:"
          head -n 5 coverage.raw

      - name: Upload merged coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage-merged
          path: |
            coverage.out
            coverage.raw

      - name: Summarize low coverage
        id: coverage-details
        shell: bash
        run: |
          set -euo pipefail

          summarize_funcs() {
            local profile=$1
            local limit=$2
            go tool cover -func="$profile" \
              | awk '$1 != "total:" {sub(/%/,"",$3); printf "%06.2f\t%s\t%s\n",$3,$1,$2}' \
              | sort -n \
              | head -n "$limit" \
              | awk -F '\t' '{pct=$1+0; printf "- %s %s (%.1f%%)\n", $2, $3, pct}'
          }

          summarize_files() {
            local profile=$1
            local limit=$2
            go tool cover -func="$profile" \
              | awk '$1 != "total:" {split($1,a,":"); file=a[1]; sub(/%/,"",$3); sum[file]+=$3; count[file]++} END {for (f in sum){printf "%06.2f\t%s\n", sum[f]/count[f], f}}' \
              | sort -n \
              | head -n "$limit" \
              | awk -F '\t' '{pct=$1+0; printf "- %s (%.1f%%)\n", $2, pct}'
          }

          engine_funcs=$(summarize_funcs coverage-engine.raw 10 || true)
          engine_files=$(summarize_files coverage-engine.raw 10 || true)
          cli_funcs=$(summarize_funcs coverage-cli.raw 10 || true)
          cli_files=$(summarize_files coverage-cli.raw 10 || true)

          emit() {
            local name=$1
            local value=$2
            {
              echo "$name<<EOF"
              echo "$value"
              echo "EOF"
            } >> "$GITHUB_OUTPUT"
          }

          emit "engine_low_funcs" "${engine_funcs:-"- (no data)"}"
          emit "engine_low_files" "${engine_files:-"- (no data)"}"
          emit "cli_low_funcs" "${cli_funcs:-"- (no data)"}"
          emit "cli_low_files" "${cli_files:-"- (no data)"}"

      - name: Find coverage comment
        if: github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository
        uses: peter-evans/find-comment@v3
        id: coverage-comment
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body-includes: "Coverage summary"

      - name: Create coverage comment
        if: github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository && steps.coverage-comment.outputs.comment-id == ''
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body: |
            Coverage summary (all platforms):
            - engine: ${{ steps.coverage.outputs.engine }}
            - cli: ${{ steps.coverage.outputs.cli }}
            - combined: ${{ steps.coverage.outputs.total }}

            Lowest-covered engine files:
            ${{ steps.coverage-details.outputs.engine_low_files }}

            Lowest-covered engine functions:
            ${{ steps.coverage-details.outputs.engine_low_funcs }}

            Lowest-covered cli files:
            ${{ steps.coverage-details.outputs.cli_low_files }}

            Lowest-covered cli functions:
            ${{ steps.coverage-details.outputs.cli_low_funcs }}

      - name: Update coverage comment
        if: github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository && steps.coverage-comment.outputs.comment-id != ''
        uses: peter-evans/create-or-update-comment@v4
        with:
          comment-id: ${{ steps.coverage-comment.outputs.comment-id }}
          edit-mode: replace
          body: |
            Coverage summary (all platforms):
            - engine: ${{ steps.coverage.outputs.engine }}
            - cli: ${{ steps.coverage.outputs.cli }}
            - combined: ${{ steps.coverage.outputs.total }}

            Lowest-covered engine files:
            ${{ steps.coverage-details.outputs.engine_low_files }}

            Lowest-covered engine functions:
            ${{ steps.coverage-details.outputs.engine_low_funcs }}

            Lowest-covered cli files:
            ${{ steps.coverage-details.outputs.cli_low_files }}

            Lowest-covered cli functions:
            ${{ steps.coverage-details.outputs.cli_low_funcs }}

      - name: Comment coverage on main
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: actions/github-script@v7
        with:
          script: |
            const body = [
              'Coverage summary (all platforms):',
              `- engine: ${process.env.COVERAGE_ENGINE}`,
              `- cli: ${process.env.COVERAGE_CLI}`,
              `- combined: ${process.env.COVERAGE_TOTAL}`,
              '',
              'Lowest-covered engine files:',
              process.env.COVERAGE_ENGINE_FILES,
              '',
              'Lowest-covered engine functions:',
              process.env.COVERAGE_ENGINE_FUNCS,
              '',
              'Lowest-covered cli files:',
              process.env.COVERAGE_CLI_FILES,
              '',
              'Lowest-covered cli functions:',
              process.env.COVERAGE_CLI_FUNCS,
            ].join('\n')

            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body,
            })
        env:
          COVERAGE_ENGINE: ${{ steps.coverage.outputs.engine }}
          COVERAGE_CLI: ${{ steps.coverage.outputs.cli }}
          COVERAGE_TOTAL: ${{ steps.coverage.outputs.total }}
          COVERAGE_ENGINE_FILES: ${{ steps.coverage-details.outputs.engine_low_files }}
          COVERAGE_ENGINE_FUNCS: ${{ steps.coverage-details.outputs.engine_low_funcs }}
          COVERAGE_CLI_FILES: ${{ steps.coverage-details.outputs.cli_low_files }}
          COVERAGE_CLI_FUNCS: ${{ steps.coverage-details.outputs.cli_low_funcs }}

      - name: Upload coverage to Coveralls
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: coverallsapp/github-action@v2
        env:
          COVERALLS_REPO_TOKEN: ${{ secrets.COVERALLS_REPO_TOKEN }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          file: coverage.out
          format: golang
          debug: true
          base-path: /foo
