# sql-runner

Сервис детерминированного исполнения цепочек SQL. Вычисляет head/tail, ищет готовый снимок состояния в `snapshot-cache`, поднимает или переиспользует песочницу через `env-manager`, выполняет head и возвращает результат вместе с метаданными слоя.

## Статус

MVP проектируется; README фиксирует целевое поведение и интерфейсы до появления кода.

## Роль в платформе

- детерминированно воспроизводит цепочки SQL как функцию от содержимого проекта;
- рассчитывает хэш tail и запрашивает соответствующий слой в `snapshot-cache`;
- поднимает/рестартует песочницу PostgreSQL через `env-manager` и выполняет head;
- возвращает результат запроса, ошибки компиляции/выполнения и метаданные слоёв;
- публикует аудит и телеметрию для мониторинга и расследований.

## Ключевой поток исполнения

1. `gateway` проксирует запрос от фронтенда с деревом SQL-проекта и указателем на head.
2. Planner строит цепочку, делит её на tail/head и считает хэш tail.
3. Клиент `snapshot-cache` ищет готовый слой; при miss запрашивает прогон tail и создание слоя.
4. `env-manager` поднимает песочницу из найденного/созданного слоя либо из базового образа.
5. Executor подключается к PostgreSQL песочницы, выполняет head, фиксирует ошибки/результат.
6. При необходимости публикуется новый слой в `snapshot-cache`.
7. Ответ уходит в `gateway` с данными о слое, логами и метриками.

## Модульная структура (MVP)

- API handler - HTTP/GRPC точка, интегрированная через `gateway`.
- Planner - парсинг дерева, разбиение на tail/head, расчёт хэша tail.
- Snapshot-cache client - поиск/публикация слоёв, учёт версий движка и настроек.
- Env binding - работа с `env-manager`, контроль TTL/лимитов песочниц.
- Executor - подключение к PostgreSQL и выполнение head с учётом параметров пользователя.
- Observability hooks - метрики, аудит, трассировки, корреляция по `request_id`.

## SQL-проект и хеширование

- Проект - дерево SQL-скриптов (`init/`, `seed/`, `test/`, `bench/` и т.д.).
- Head - конкретный файл, который выполняется и отдаёт результат пользователю.
- Tail - все предшествующие файлы/шаги; именно его хэш используется как ключ кэша.
- Tail хэшируется по содержимому, путям, версии движка/расширений и настройкам окружения.
- Ветвление цепочек поддерживается естественно: общий prefix даёт общий слой.

## Модель заданий

- Каждая цепочка исполняется как задание. Задание создаётся, исполняется асинхронно, поддерживает прогресс, отмену и сборку GC.
- Задания бывают:
  - **короткие** - создаются и исполняются одним запросом (fire-and-forget + быстрый polling).
  - **длинные** - формируются из нескольких частей (append к уже созданному заданию), чтобы не передавать большие тела и показывать прогресс по мере сборки цепочки.
- Прогресс: статус (`pending` → `preparing` → `running` → `publishing` → `completed`/`failed`/`canceled`), этапы (парсинг, поиск снапшота, поднятие песочницы, выполнение head), промежуточные логи.
- Время жизни задания: `job_ttl` задаётся при создании; продвинутое управление TTL/пролонгацией доступно на премиальных планах. GC периодически удаляет просроченные задания и артефакты.

## API (черновик)

- `POST /v1/jobs` — создать задание.
  - Вход: `request_id`, `user_id`, `project_tree` (путь → содержимое/etag), `head_path`, `variables`, `snapshot_ttl`, `job_ttl`, `timeout_ms`, `telemetry_context`.
  - Используется и для коротких цепочек: можно сразу отправить весь проект и получить `job_id` + быстрый ответ о старте.
- `POST /v1/jobs/{job_id}/append` — добавить часть проекта/цепочки к уже созданному заданию (для длинных сценариев).
- `POST /v1/jobs/{job_id}/run` — начать исполнение, если задание собиралось частями.
- `GET /v1/jobs/{job_id}` — статус, прогресс, текущий этап, tail_hash, ссылки на логи/результат.
- `GET /v1/jobs/{job_id}/logs` — инкрементальные логи (polling) или SSE/WS (если добавим).
- `POST /v1/jobs/{job_id}/cancel` — отменить выполнение и зачистить песочницу.
- Webhooks (опционально): уведомления о `completed`/`failed`/`canceled` для внешних интеграций.
- Ответ успешного выполнения:
  - `status` (`completed`), `rows` или описание ошибки/отмены;
  - `snapshot` (tail_hash, layer_id, hit/miss);
  - `progress` (финальный этап, длительность), `logs` (последний срез) или ссылка;
  - `metrics` (latency, cache_hit, retries).

## Интеграции

- `snapshot-cache` - поиск и публикация слоёв по `tail_hash`.
- `env-manager` - создание/рестарт песочниц, сетевые policy (PostgreSQL доступен только `sql-runner`).
- `audit-log` - запись действий и ошибок пользователя.
- `telemetry/exporter` - метрики Prometheus и трассировки.

## Наблюдаемость и безопасность

- Метрики: время холодного/тёплого старта песочницы, длительность head, доля cache hit, ошибки подключения/SQL, прогресс заданий, доля отмен/таймаутов, загрузка GC.
- Логи: структурированные, без пользовательских данных; корреляция через `request_id` и `job_id`.
- Аудит: кто/что/когда выполнил и с каким результатом/отменой.
- Сетевые границы: доступ к PostgreSQL песочницам ограничен `sql-runner`; внешние вызовы идут только через `gateway`.

## Локальная разработка (набросок)

- Код сервиса пока не добавлен; запуск описывается после появления реализации.
- План: использовать `infra/local-dev/` для docker-compose/minikube, подготовить профили окружений и набор переменных (`POSTGRES_DSN`, `SNAPSHOT_CACHE_URL`, `ENV_MANAGER_URL` и т.п.).
- После появления кода сюда попадут команды для сборки, запуска, тестов и линтеров.

## Backlog README

- Уточнить формат `project_tree`, правила построения tail/head и контракт по append.
- Добавить схемы ошибок и коды ответов.
- Описать политику дедупликации/GC слоёв, TTL песочниц и TTL заданий (с правилами премиум-планов).
- Обновить раздел локального запуска после добавления кода и инфраструктурных манифестов.
